---
title: "Blazor: Binding into children"
date: 2025-03-03T11:44:30+10:00
type: "post"
slug: "blazor-binding-into-children"
tags: ['blazor']
---

I've had [trouble](/content/posts/25-blazor-net5/index.md) working with child components, where I felt that extracting a component was difficult and unclear.  
I stand by that in general, but I did learn that I'm doing it kinda wrong ðŸ˜…

<!--more-->  

The main thing I'm looking at here is extracting form components into child components, because extracting other elements is reasonably straightforward.  
This technique can be used for those too though.  
Another thing to note is that this is in the [documentation](https://learn.microsoft.com/en-us/aspnet/core/blazor/forms/binding?view=aspnetcore-9.0#input-component-with-full-developer-control) reasonably clearly, but it's a hefty document and I missed it , *excuses excuses*.  

# My first attempt (works, but not really)
Here I have a basic form with an `InputTextArea`:  
```html
<EditForm context="editContext">
    <InputTextArea.../>
    ...
</EditForm>
```

I decided I wanted to decorate that `InputTextArea` with some text, buttons, etc and use it elsewhere, so I extracted it.  

```html
<InputTextArea @bind-Value="Value".../>
additional buttons and cool stuff...

@code{
    [Parameter] public string Value{get;set;}
}
```

```html
<EditForm context="editContext">
    <MyInput @bind-Value="WhateverTheTextPropIs"/>
    ...
</EditForm>
```

This kinda works, but not really:
- `@bind` in the parent to the child, then `@bind` in the child doesn't update the parent value when it changes
- Validation works, but only field level. No model or more complex validation/change tracking works properly

# The second attempt  (works better, but still wrong)

The first problem I initially solved with a custom setter and exposing the change event:
```cs
string? _value = null;

[Parameter] public string? Value{
    get => _value;
    set {
        if(value != _value){
            ValueChanged.Invoke(value);
            _value = value;
        }
    }
}

[Parameter] public EventCallback<string?> ValueChanged { get; set; }
```

This ensures that when the value is changed, it's passed back up to the parent to be set via the `ValueChanged` event.

As for validation, if it's just `Required` or some simple validation, it'll work fine as `EditContext` cascades automatically, but I had a more complex function in mind.  

I want to be able to do some basic change tracking, wherein I needed to be able to identify which property a change was coming from so I could capture the old and new value.  

In the above code, the changed property reported is `Value` and the model is just the child component class, because that's all the `InputTextArea` knows.  
I thought it'd somehow track the binding through from the parent, but with the current setup, no.  

# The correct answer (imo)

The extra two special sauces are:   
- No `@bind` in the child
- Pass through the `ValueExpression` from the parent

`ValueExpression` indicates how the value relates to the model, and I'm leaving the explanation there because I don't really understand it.  
It's required to wire things up correctly though.

`@bind` actually generates the `ValueChanged` and `ValueExpressions` automatically, and if you try to pass the parent values into the `InputTextArea`, it'll complain about them already being generated by the `@bind`.  
This is why we can't use `@bind` on that element in the child, and we just need pass along the info from the parent.  

```html
<!-- parent -->
<EditForm context="editContext">
    <MyInput @bind-Value="WhateverTheTextPropIs"/>
    ...
</EditForm>

<!-- child -->
<InputTextArea Value="@Value" ValueChanged="@ValueChanged" ValueExpression="@ValueExpression" />

@code{
    [Parameter] public string? Value{ get; set; }
    [Parameter] public EventCallback<string?> ValueChanged { get; set; }
    [Parameter] public Expression<Func<string?>> ValueExpression { get; set; }
}
```

We no longer need that custom setter, we just pass everything through.  

# Conclusion  
Writing this all out, it makes a load of sense, and it comes from barely understanding the `@` syntax, what `@bind` does for you, and the documentation really going ham into `@bind`.  

## Additional notes
- The names are relevant: `public string? X` means that the parent will go `@bind-X="...`  
- The actual change detection events are done like this: 
```cs
editContext.OnFieldChanged += Handler;

private void Handler(object? sender, FieldChangedEventArgs e){
    var model = e.FieldIdentifier.Model;
    var fieldChanged = e.FieldIdentifier.FieldName;
    ...
}
```
- Stying those form components sucks, lots of `::deep` usage  